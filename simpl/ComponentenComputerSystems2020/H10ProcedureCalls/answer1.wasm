@include "16bitJumper.wasm"

.data MyData : DATAMEM      # summation loop is computing:
0x00:   WORD        0d032   #
        WORD        0d016   # 32/16  =  2
        WORD        0d064   #
        WORD        0d008   # 64/8   =  8
        WORD        0d128   #
        WORD        0d032   # 128/32 =  4
        WORD        0d000   #         ---- +
        WORD        0d000   #          14     <- desired result

.data MyRegisters : REGISTERS
@include "register_constants.wasm"

.code MyCode : REGSTACK, MyData, MyRegisters
LOADI   $arg1, 19  # set numerator
LOADI   $arg2,  5  # set denominator
JSR     divide     # divide works! (see $val1 and $val2)

LOADI   $s1, 0  # index into data memory
LOADI   $s2, 0  # initialize sum to zero
loop:   # summation loop
LW      $arg1,  0x00,  $s1   # load numerator
ADDI    $s1,    $s1,   1
LW      $arg2,  0x00,  $s1   # load denominator
ADDI    $s1,    $s1,   1
BEQ     $arg2,  $zero, done  # done when denominator is zero
JSR     divide               # divide numerator by denominator
ADD     $s2,    $s2,   $val1 # sum each quotient
BRA     loop
done:
HALT

# ----------------------------
# returns quotient and remainder of arg1 (numerator) divided by arg2 (denominator)
# val1 = arg1 / arg2 (quotient)
# val2 = arg1 % arg2 (remainder)
# ----------------------------
divide:
# add your stack instructions here

SW      $arg1, 0, $zero
SW      $arg2, 1, $zero
SW      $s1, 2, $zero
SW      $s2, 3, $zero

LOADI   $s1, 0
divide_loop:
SUB     $s2,   $arg1, $arg2
ANDI    $s2,   $s2,   0x8000       # mask with 'negative bit'
BNE     $s2,   $zero, divide_done  # branch when 'negative bit' is set
SUB     $arg1, $arg1, $arg2
ADDI    $s1,   $s1, 1
BRA     divide_loop
divide_done:
COPY    $val1, $s1
COPY    $val2, $arg1
# add your stack instructions here

LW      $arg1, 0, $zero
LW      $arg2, 1, $zero
LW      $s1, 2, $zero
LW      $s2, 3, $zero
RETURN  $ra